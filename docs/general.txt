cargo
    rust dependency manager

rust pattern uses underscore

rust works just like c, after the compilation the first
function to be run is always the fn main 

all functions that use {name}! are actually macros

fn syntax declares a new function

String::new(); function that returns a new instance of a string
by default strings is a growable utf 8 encoded text

we can also use functions from std without importing it
by using std::{use of the function}

just like variables, references are immutable by default

the read_line method writes the input into the string that was passed,
however it also returns an Enumeration called Result, that can be either
{Ok} or {Err}
this enumeration type has its associated methods, for example the 
expect one. If expect receives {Err}, it crashes the program and
displays the message is its argument, otherwise it just returns the
value that Ok is referring to.

the println! macro works like fstrings in python, however for expressions
you have to use {}. For example:
println!("x é {x} e x² é {}", x*x)

crates are the smallest unit of code that rust compiler
accepts, can be either a program or a library

When an external dependency is added, cargo fetches the
latest version of everything from crates.io, which is where
people upload their open source projects to.

when you build a project for the first time, the cargo lock
specifies the versions of the dependencies that match your
project. This ensures that the version of the dependency you
use won't change unless you do so.

let secret_number = rand::thread_rng().gen_range(1..=100);
the first part, rng::thread_rng gives us a random number
generator that is local to the thread and seeded by the OS.
The next part uses the expression to create a number between
1 and 100 (inclusive).

rust usually defaults numbers to i32

when using .parse() to convert from one type to another
rust uses the type from the variable to do so.
for example
let abc: u32 = ....parse();
rust will look at the u32 and try to parse it that way
additionally, it returns a Result type just like
io::stdin().read_line()

even when an expression is supposed to return a result
when a "continue" shows up it steals the execution and
skips to the next step

in order to shadow a variable simply redeclare it 
using let. The let is scope dependent, so if you
shadow a variable inside of a function, outside it
it will have the same value as before.

shadowing is useful because you can use it to change the
type of a variable, which a reassign of a mut varibable 
cannot do

rust data types belong to two super groups,
compound and scalar

rust is statically typed, which means it should know the
name of all variables at compile time. It can infer that 
based on the value and how we use that

scalars represent a single value, and they can be 
integers, floats, booleans and chars
for ints, isize and usize are architectural dependent,
either 32 or 64 bit

compounds are divided into two main groups,
tuples and arrays
one tuple can store multiple types, however
it cannot grow in size.

parameters are the variables that are passed to
the function, arguments are the values themselves

Statements are instructions that perform some 
action and do not return a value.
Expressions evaluate to a resultant value.

{} this is a scope block. (and also an expression)
expressions do not have ending semicolons,
so if you finish what would be an expression with
a semicolon, you turn it into an statement, making it
not return any value.

functions must always declare the return type,
and they return the value of the final expression
in the body of a function, however you can also
use the return keyword.
for example:
fn returns1 () -> i32 {1}