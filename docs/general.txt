cargo
    rust dependency manager

rust pattern uses underscore

rust works just like c, after the compilation the first
function to be run is always the fn main 

all functions that use {name}! are actually macros

fn syntax declares a new function

String::new(); function that returns a new instance of a string
by default strings is a growable utf 8 encoded text

we can also use functions from std without importing it
by using std::{use of the function}

just like variables, references are immutable by default

the read_line method writes the input into the string that was passed,
however it also returns an Enumeration called Result, that can be either
{Ok} or {Err}
this enumeration type has its associated methods, for example the 
expect one. If expect receives {Err}, it crashes the program and
displays the message is its argument, otherwise it just returns the
value that Ok is referring to.

the println! macro works like fstrings in python, however for expressions
you have to use {}. For example:
println!("x é {x} e x² é {}", x*x)

crates are the smallest unit of code that rust compiler
accepts, can be either a program or a library

When an external dependency is added, cargo fetches the
latest version of everything from crates.io, which is where
people upload their open source projects to.

when you build a project for the first time, the cargo lock
specifies the versions of the dependencies that match your
project. This ensures that the version of the dependency you
use won't change unless you do so.

let secret_number = rand::thread_rng().gen_range(1..=100);
the first part, rng::thread_rng gives us a random number
generator that is local to the thread and seeded by the OS.
The next part uses the expression to create a number between
1 and 100 (inclusive).

rust usually defaults numbers to i32

when using .parse() to convert from one type to another
rust uses the type from the variable to do so.
for example
let abc: u32 = ....parse();
rust will look at the u32 and try to parse it that way
additionally, it returns a Result type just like
io::stdin().read_line()

even when an expression is supposed to return a result
when a "continue" shows up it steals the execution and
skips to the next step

in order to shadow a variable simply redeclare it 
using let. The let is scope dependent, so if you
shadow a variable inside of a function, outside it
it will have the same value as before.

shadowing is useful because you can use it to change the
type of a variable, which a reassign of a mut varibable 
cannot do

rust data types belong to two super groups,
compound and scalar

rust is statically typed, which means it should know the
name of all variables at compile time. It can infer that 
based on the value and how we use that

scalars represent a single value, and they can be 
integers, floats, booleans and chars
for ints, isize and usize are architectural dependent,
either 32 or 64 bit

compounds are divided into two main groups,
tuples and arrays
one tuple can store multiple types, however
it cannot grow in size.

parameters are the variables that are passed to
the function, arguments are the values themselves

Statements are instructions that perform some 
action and do not return a value.
Expressions evaluate to a resultant value.

{} this is a scope block. (and also an expression)
expressions do not have ending semicolons,
so if you finish what would be an expression with
a semicolon, you turn it into an statement, making it
not return any value.

functions must always declare the return type,
and they return the value of the final expression
in the body of a function, however you can also
use the return keyword.
for example:
fn returns1 () -> i32 {1}

both for branching (if else) and matching
the expressions inside the curly brackets are
called arms

in rust the expression 
if 3 {}
is not valid because 3 does not
resolve to true; the condition must be a bool

because if is an expression, we can use 
let a = if condition {b} else {c}. It is not
exactly the same as in C beacuse in C the if
would behave like an statement. Remember that
the rust compiler should know the type of a
variable before compiling, so b and c must be
of the same type.
Therefore things like
if cond {4}
are valid.

loops are also an expression, and you can
use break to return a value updated inside
a loop, just like in the example below
let result = loop {
    ...
    {break return_value;}
    ...
};
if a return is used inside of a loop that is
inside of a function, in that case the return
breaks out of the function entirely.
if you have two loops, you can add labels to
them so you can specify to which one of them
your continue or break applies to. For example:
'outside: loop {
    ...
    loop {
        break 'outside;
    }
}

both while and for are expressions, but they
always return the unit. When possible opt for
for, because it generates more optimized code
than while due to not needing to compare to
the length of the array ate every iteration.

basics of ownership:
 - each value has an owner
 - only one owner at a time
 - when the owner goes out of scope,
the value will be dropped

variables are valid from where they were
declared until the end of the current scope

the contents of the string data type 
is stored in the heap, due to its size
not being known at compile time. It is
managed by the String type. It is slower than
literal texts (let a = "abc...";).
The basic structure of a string is
- a pointer to the heap with the text
- a len
- a capacity
that means when 
let a = String...
let b = a
only the basic structure is copied, the
contents in the heap are not. To deal with
"double free" errors, the a variable is invalidaded,
so each piece in the memory only has one owner.
Because of that if we try to use a after b is created
we will get an error (invalidaded reference).
Therefore, what actually happens is the stack data
being *moved* from a to b.
Because of that, rust will never actually do
deep copies naturally (copying data and pointers)

instead of having a garbage collector or
demanding the programmer to manage the memory
rust returns the memory once the variable
that owns it goes out of scope. When that happens,
rust calls a special function called drop that 
manages the memory by itself. This is very similar
to a pattern in C++ called RAII
=> Resource Acquisition is Initialization

When you reassing a value to a variable, drop is
also called, but this time drop is called to get
rid of the old value that was stored.

Rust has a special annotation called the Copy trait,
and it is destined to variables that are stored on the
stack. If a type implements the Copy trait, the variables
that use that type are not moved, but always copied. That
makes them valid after a new variable has an assignment made.
A type cannot have both the Drop and the Copy traits. That is
because it's like we're trying to make a value both valid
and unvalid after another variable used it, also, copy
assumes the value is on the stack and drop assumes it it
one the heap.
Passing values to a functions works like assigning old values
to new variables, if they have the Copy trait they are still
valid, however if they don't you must assume the value is not
useful anymore.